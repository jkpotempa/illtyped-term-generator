import Distribution.Simple.Utils

main = putStrLn "executed main"

len :: [a] -> Int
len = foldr (\_ n -> n+1) 0

(<) :: Int -> Int -> Bool
(<) = (Prelude.<)

(==) :: Bool -> Bool -> Bool
(==) = (Prelude.==)

ifthenelse :: Bool -> a -> a -> a
ifthenelse c a b = if c then a else b

welltypedProgram = let y1 = (((\ x1 x3 x4 x5 x6 x7 x8 x9 -> ((+)) ((if (x1) then (((.)) ((\x2 -> 1)) ((case x4 of Nothing -> x3; Just x -> x;)) (((Main.==)) (x5) (x6) ) ) else ((case x8 of Nothing -> (negate) (x7) ; Just x -> x;)))) (x9) )) ((fst) ((((.)) ((fst) ((id,False)) ) ((\x21 -> (id) (x21) )) (((||)) (((||)) (False) (True) ) (let y12 = (id) in (False)) ) ,((++)) (((\ x10 -> x10)) (((.)) (id) (id) ([]) ) ) (((.)) (let y9 = (id) in (id)) (((.)) ((++)) (id) ([]) ) ((map) (ifthenelse) ([]) ) ) )) ) ((\x22 -> let _ = (x22 :: Bool) in ((.)) (fst) ((\x23 -> (snd,(safeHead) ([]) ))) (safeHead) )) ((case (map) (let y13 = ((&&)) in (filter)) ((fst) (((id) ([]) ,safeTail)) )  of [] -> ((\ x24 x25 x26 x29 x30 -> (if (((||)) (x24) (x25) ) then (x26) else (((.)) (x29) (negate) (x30) )))) (True) ((snd) (((:),((||)) (False) (False) )) ) ((safeHead) ([]) ) ((case (id) ((safeHead) ([]) )  of Nothing -> (\x148 -> let _ = (x148 :: Int) in (safeHead) ([]) ); Just x -> x;)) ((case (if (((&&)) (False) (True) ) then (((:)) ((.)) ([]) ) else (((:)) ((.)) ([]) )) of [] -> (snd) ((fst,1)) ; (z101:z102) -> (snd) ((id,1)) ;)) ; (z17:z18) -> ((.)) ((snd) ((((+)) (1) (0) ,snd)) ) (((.)) ((\x151 -> snd)) ((\x152 -> (case x152 of [] -> False; (z111:z112) -> True;))) ((fst) ((z18,(Main.==))) ) ) (((Main.<),((:),(safeHead) ([]) ))) ;)) (((Main.<)) ((case [] of [] -> (if (((.)) ((case [] of [] -> id; (z119:z120) -> id;)) ((if (False) then (snd) else (fst))) ((True,True)) ) then (((-)) ((if (True) then (0) else (0))) ((case [] of [] -> 0; (z125:z126) -> 1;)) ) else (((.)) ((\x161 -> 0)) (let y78 = (False) in (map)) (map) )); (z117:z118) -> (negate) ((negate) ((case z118 of [] -> 0; (z129:z130) -> z117;)) ) ;)) (((+)) (((-)) ((fst) ((1,True)) ) ((negate) ((case [] of [] -> 0; (z131:z132) -> 0;)) ) ) ((len) ((map) (snd) ([]) ) ) ) ) ((if (True) then ((id) (((Main.<)) ((id) (((.)) (id) (negate) (1) ) ) (((\ x164 -> x164)) (let y84 = (1) in (y84)) ) ) ) else ((snd) ((((&&)) (((Main.==)) (False) (False) ) ((if (True) then (True) else (False))) ,((||)) (((Main.<)) (0) (1) ) (((Main.==)) (False) (True) ) )) ))) (((-)) (0) ((case (safeHead) ((fst) (([],[])) )  of Nothing -> (id) (((-)) ((negate) (0) ) ((negate) (0) ) ) ; Just x -> x;)) ) ((if (((Main.==)) (((||)) (((\ x168 -> x168)) ((if (True) then (True) else (True))) ) ((id) (((||)) (True) (True) ) ) ) ((if (((&&)) (True) (False) ) then (((.)) (id) ((if (False) then (id) else (id))) ((case [] of [] -> True; (z165:z166) -> False;)) ) else ((fst) ((True,(Main.<))) ))) ) then ((if (((Main.<)) ((case (case [] of [] -> []; (z171:z172) -> z172;) of [] -> 0; (z169:z170) -> ((+)) (z169) (1) ;)) (((.)) (len) (let y100 = (fst) in (y100)) (([],negate)) ) ) then (let y102 = ((safeHead) (((++)) ([]) ([]) ) ) in (((.)) ((case y102 of Nothing -> id; Just x -> x;)) ((\x185 -> x185)) ((safeHead) ([]) ) )) else ((fst) (((safeHead) ([]) ,(id) ((-)) )) ))) else (((\ x190 -> x190)) ((safeHead) ((if (((Main.<)) (1) (0) ) then ((safeTail) ([]) ) else ((if (False) then ([]) else ([]))))) ) ))) (((-)) ((case (case (snd) (([],[]))  of [] -> []; (z209:z210) -> (if (((Main.<)) (z209) (0) ) then ((safeTail) (z210) ) else (((++)) ([]) ([]) ));) of [] -> ((+)) ((len) ((safeTail) ([]) ) ) (((+)) ((if (True) then (1) else (1))) (0) ) ; (z207:z208) -> ((\ x197 -> (len) (x197) )) (let y124 = (((+)) (0) (z207) ) in ((if (True) then (z208) else (z208)))) ;)) ((len) (((++)) ((case [] of [] -> (case [] of [] -> []; (z225:z226) -> z225;); (z223:z224) -> (filter) (fst) (z223) ;)) ((case ((.)) (safeHead) (id) ([])  of Nothing -> (if (True) then ([]) else ([])); Just x -> x;)) ) ) ) ) in ((id) ((fst) (((snd) ((snd,((+)) (0) (y1) )) ,((&&)) ((if (((Main.<)) (y1) (y1) ) then (let y3 = (False) in (y3)) else (((.)) (id) (id) (True) ))) ((id) (((||)) (True) (False) ) ) )) ) )

illtypedProgram  = let y1 = (((\ x1 x3 x4 x5 x6 x7 x8 x9 -> ((+)) ((if (x1) then (((.)) ((\x2 -> 1)) ((case x4 of Nothing -> x3; Just x -> x;)) (((Main.==)) (x5) (x6) ) ) else ((case x8 of Nothing -> (negate) (x7) ; Just x -> x;)))) (x9) )) ((fst) ((((.)) ((fst) ((id,False)) ) ((\x21 -> (id) (x21) )) (((||)) (((||)) (False) (True) ) (let y12 = (id) in (False)) ) ,((++)) (((\ x10 -> x10)) (((.)) (id) (id) ([]) ) ) (((.)) (let y9 = (id) in (id)) (((.)) ((++)) (id) ([]) ) ((map) (ifthenelse) ([]) ) ) )) ) ((\x22 -> let _ = (x22 :: Bool) in ((.)) (fst) ((\x23 -> (snd,(safeHead) ([]) ))) (safeHead) )) ((case (map) (let y13 = ((&&)) in (filter)) ((fst) (((id) ([]) ,safeTail)) )  of [] -> ((\ x24 x25 x26 x29 x30 -> (if (((||)) (x24) (x25) ) then (x26) else (((.)) (x29) (negate) (x30) )))) (True) ((snd) (((:),((||)) (False) (False) )) ) ((safeHead) ([]) ) ((case (id) ((safeHead) ([]) )  of Nothing -> (\x148 -> let _ = (x148 :: Int) in (safeHead) ([]) ); Just x -> x;)) ((case (if (((&&)) (False) (True) ) then (((:)) ((.)) ([]) ) else (((:)) ((.)) ([]) )) of [] -> (snd) ((fst,1)) ; (z101:z102) -> (snd) ((id,1)) ;)) ; (z17:z18) -> ((.)) ((snd) ((((+)) (1) (0) ,snd)) ) (((.)) ((\x151 -> snd)) ((\x152 -> (case x152 of [] -> False; (z111:z112) -> True;))) ((fst) ((z18,(Main.==))) ) ) (((Main.<),((:),(safeHead) ([]) ))) ;)) (((Main.<)) ((case [] of [] -> (if (((.)) ((case [] of [] -> id; (z119:z120) -> id;)) ((if (False) then (snd) else (fst))) ((True,True)) ) then (((-)) ((if (True) then (0) else (0))) ((case [] of [] -> 0; (z125:z126) -> 1;)) ) else (((.)) ((\x161 -> 0)) (let y78 = (False) in (map)) (map) )); (z117:z118) -> (negate) ((negate) ((case z118 of [] -> 0; (z129:z130) -> z117;)) ) ;)) (((+)) (((-)) ((fst) ((1,True)) ) ((negate) ((case [] of [] -> 0; (z131:z132) -> 0;)) ) ) ((len) ((map) (snd) ([]) ) ) ) ) ((if (True) then ((id) (((Main.<)) ((id) (((.)) (id) (negate) (1) ) ) (((\ x164 -> x164)) (let y84 = (1) in (y84)) ) ) ) else ((snd) ((((&&)) (((Main.==)) (False) (False) ) ((if (True) then (True) else (False))) ,((||)) (((Main.<)) (0) (1) ) (((Main.==)) (False) (True) ) )) ))) (((-)) (0) ((case (safeHead) ((fst) (([],[])) )  of Nothing -> (id) (((-)) ((negate) (0) ) ((negate) (0) ) ) ; Just x -> x;)) ) ((if (((Main.==)) (((||)) (((\ x168 -> x168)) ((if (True) then (True) else (True))) ) ((id) (((||)) (True) (True) ) ) ) ((if (((&&)) (True) (False) ) then (((.)) (id) ((if (False) then (id) else (id))) ((case [] of [] -> True; (z165:z166) -> False;)) ) else ((fst) ((True,(Main.<))) ))) ) then ((if (((Main.<)) ((case (case [] of [] -> []; (z171:z172) -> z172;) of [] -> 0; (z169:z170) -> ((+)) (z169) (1) ;)) (((.)) (len) (let y100 = (fst) in (y100)) (([],negate)) ) ) then (let y102 = ((safeHead) (((++)) ([]) ([]) ) ) in (((.)) ((case y102 of Nothing -> id; Just x -> x;)) ((\x185 -> x185)) ((safeHead) ([]) ) )) else ((fst) (((safeHead) ([]) ,(id) ((-)) )) ))) else (((\ x190 -> x190)) ((safeHead) ((if (((Main.<)) (1) (0) ) then ((safeTail) ([]) ) else ((if (False) then ([]) else ([]))))) ) ))) (((-)) ((case (case (snd) (([],[]))  of [] -> []; (z209:z210) -> (if (((Main.<)) (z209) (0) ) then ((safeTail) (z210) ) else (((++)) ([]) ([]) ));) of [] -> ((+)) ((len) ((safeTail) ([]) ) ) (((+)) ((if (True) then (1) else (1))) (0) ) ; (z207:z208) -> ((\ x197 -> (len) (x197) )) (let y124 = (((+)) (0) (z207) ) in ((if (True) then (z208) else (z208)))) ;)) ((len) (((++)) ((case [] of [] -> (case [] of [] -> []; (z225:z226) -> z225;); (z223:z224) -> (filter) (fst) (z223) ;)) ((case ((.)) (safeHead) (id) ([])  of Nothing -> (if (True) then ([]) else ([])); Just x -> x;)) ) ) ) ) in ((id) ((fst) (((snd) ((((map) ((if ((fst) ((((Main.==)) (let y132 = (map) in (False)) (((&&)) (False) (True) ) ,(filter) ((if (True) then (snd) else (snd))) (let y130 = ([]) in (y130)) )) ) then ((if (((&&)) (((\ x202 -> x202)) (((Main.==)) (True) (False) ) ) (((Main.==)) (((||)) (True) (True) ) (((Main.==)) (False) (False) ) ) ) then (((.)) ((case (safeTail) ([])  of [] -> (\x203 -> id); (z241:z242) -> fst;)) (snd) ((True,(id,(+)))) ) else (id))) else (id))) (((++)) ((fst) (((fst) (([],0)) ,filter)) ) ((filter) (((.)) ((fst) ((fst,filter)) ) ((case (safeHead) ([])  of Nothing -> (id) (fst) ; Just x -> x;)) (((id,False),((&&)) (True) (False) )) ) ((filter) ((case let y142 = ((+)) in ([]) of [] -> (id) (id) ; (z255:z256) -> (\x208 -> let _ = (x208 :: Bool) in False);)) ((case (safeHead) ([])  of Nothing -> (id) ([]) ; Just x -> x;)) ) ) ) ) ((safeTail) ([]) ),((+)) (0) (y1) )) ,((&&)) ((if (((Main.<)) (y1) (y1) ) then (let y3 = (False) in (y3)) else (((.)) (id) (id) (True) ))) ((id) (((||)) (True) (False) ) ) )) ) )