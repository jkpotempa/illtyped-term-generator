import Distribution.Simple.Utils

main = putStrLn "executed main"

len :: [a] -> Int
len = foldr (\_ n -> n+1) 0

(<) :: Int -> Int -> Bool
(<) = (Prelude.<)

(==) :: Bool -> Bool -> Bool
(==) = (Prelude.==)

ifthenelse :: Bool -> a -> a -> a
ifthenelse c a b = if c then a else b

welltypedProgram = (case (filter) ((case (if (True) then (((.)) (id) ((id) ((\x1 -> x1)) ) (((.)) ((\x2 -> [])) ((&&)) (((&&)) (True) (True) ) ) ) else (((.)) ((if (((Main.<)) (0) (0) ) then (fst) else ((if (False) then (fst) else (fst))))) (((.)) ((if (False) then (id) else (id))) ((\x13 -> fst)) ((safeTail) ([]) ) ) ((([],safeTail),((++)) ([]) ([]) )) )) of [] -> let y6 = (1) in (snd); (z3:z4) -> (snd) (((&&),(case (safeHead) (z4)  of Nothing -> z3; Just x -> x;))) ;)) (((++)) ((safeTail) ((fst) ((let y10 = ([]) in (y10),((-)) (0) (0) )) ) ) (((++)) ((safeTail) (((\ x23 -> [])) (let y13 = (safeHead) in (0)) ) ) (((:)) (((:),(id) (True) )) ((safeTail) ((safeTail) ([]) ) ) ) ) )  of [] -> (case (id) ((safeHead) ((id) ((fst) (([],(-))) ) ) )  of Nothing -> (filter) (id) ((case (case (if ((case [] of [] -> False; (z33:z34) -> True;)) then ((map) ((:)) ([]) ) else ((id) ([]) )) of [] -> (snd) ((snd,[])) ; (z31:z32) -> (filter) (id) (((++)) ([]) ([]) ) ;) of [] -> (fst) ((let y22 = ([]) in (y22),((Main.<)) (0) (1) )) ; (z29:z30) -> (safeTail) (((++)) ((safeTail) ([]) ) (((++)) ([]) ([]) ) ) ;)) ; Just x -> x;); (z1:z2) -> ((.)) ((\x25 -> (safeTail) (((\ x26 -> x25)) ((id) (let y24 = ([]) in (0)) ) ) )) ((case (id) (((.)) ((\x29 -> x29)) (id) ((safeHead) ((if (True) then ([]) else ([]))) ) )  of Nothing -> (\x27 -> ((:)) (((&&)) (x27) (False) ) ((safeTail) ((filter) (id) ([]) ) ) ); Just x -> x;)) ((fst) ((((||)) (((&&)) (True) (let y29 = ((:)) in (False)) ) (((Main.<)) ((len) ([]) ) ((negate) (0) ) ) ,filter)) ) ;)

illtypedProgram  = (case (filter) ((case (if (True) then (((.)) (id) ((id) ((\x1 -> (if (let y31 = ((id) (True) ) in (((:)) ((case (if (((&&)) (((||)) (True) (y31) ) (y31) ) then (((\ x38 -> x38)) (((.)) (safeHead) (id) ([]) ) ) else (((.)) (id) (((.)) (id) (id) (id) ) ((safeHead) ([]) ) )) of Nothing -> ((Main.==)) ((id) (((Main.==)) (y31) (False) ) ) ((if (((.)) (id) (id) (True) ) then ((case [] of [] -> False; (z61:z62) -> True;)) else ((if (y31) then (True) else (True))))) ; Just x -> x;)) ((id) (((++)) (((.)) ((id) (fst) ) (id) (([],len)) ) ((snd) (((.),[])) ) ) ) )) then (((Main.<)) (((-)) ((negate) (let y44 = ((if ((id) (False) ) then ((safeTail) ([]) ) else ([]))) in ((snd) ((negate,1)) )) ) (0) ) (0) ) else (((.)) (fst) ((\x873 -> (((+)) ((case ((++)) ([]) ([])  of [] -> ((-)) (1) (0) ; (z783:z784) -> (case [] of [] -> 0; (z787:z788) -> z783;);)) ((fst) ((x873,(.))) ) ,(+)))) ((snd) (((negate) ((fst) ((1,(||))) ) ,(len) ((safeTail) (((++)) ([]) ([]) ) ) )) ) )))) ) (((.)) ((\x2 -> [])) ((&&)) (((&&)) (True) (True) ) ) ) else (((.)) ((if (((Main.<)) (0) (0) ) then (fst) else ((if (False) then (fst) else (fst))))) (((.)) ((if (False) then (id) else (id))) ((\x13 -> fst)) ((safeTail) ([]) ) ) ((([],safeTail),((++)) ([]) ([]) )) )) of [] -> let y6 = (1) in (snd); (z3:z4) -> (snd) (((&&),(case (safeHead) (z4)  of Nothing -> z3; Just x -> x;))) ;)) (((++)) ((safeTail) ((fst) ((let y10 = ([]) in (y10),((-)) (0) (0) )) ) ) (((++)) ((safeTail) (((\ x23 -> [])) (let y13 = (safeHead) in (0)) ) ) (((:)) (((:),(id) (True) )) ((safeTail) ((safeTail) ([]) ) ) ) ) )  of [] -> (case (id) ((safeHead) ((id) ((fst) (([],(-))) ) ) )  of Nothing -> (filter) (id) ((case (case (if ((case [] of [] -> False; (z33:z34) -> True;)) then ((map) ((:)) ([]) ) else ((id) ([]) )) of [] -> (snd) ((snd,[])) ; (z31:z32) -> (filter) (id) (((++)) ([]) ([]) ) ;) of [] -> (fst) ((let y22 = ([]) in (y22),((Main.<)) (0) (1) )) ; (z29:z30) -> (safeTail) (((++)) ((safeTail) ([]) ) (((++)) ([]) ([]) ) ) ;)) ; Just x -> x;); (z1:z2) -> ((.)) ((\x25 -> (safeTail) (((\ x26 -> x25)) ((id) (let y24 = ([]) in (0)) ) ) )) ((case (id) (((.)) ((\x29 -> x29)) (id) ((safeHead) ((if (True) then ([]) else ([]))) ) )  of Nothing -> (\x27 -> ((:)) (((&&)) (x27) (False) ) ((safeTail) ((filter) (id) ([]) ) ) ); Just x -> x;)) ((fst) ((((||)) (((&&)) (True) (let y29 = ((:)) in (False)) ) (((Main.<)) ((len) ([]) ) ((negate) (0) ) ) ,filter)) ) ;)