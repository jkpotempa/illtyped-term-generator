let safeHead list = 
    match list with
    | [] -> None
    | (h::t) -> Some h

let safeTail list =
    match list with
    | [] -> []
    | (h::t) -> t

let compose f g x = f (g x)

let ifthenelse c a b = if c then a else b

let lam1 = (snd) (((lam2) ((List.cons) (1) ([]) ) ,(compose) ((fun x6 -> x6)) ((fun x10 -> lam1)) (((<)) (1) (1) ) )) 
and lam2 = (if ((lam3) ((Fun.id) ((Fun.id) (false) ) ) ) then ((fun x3 -> (List.cons) (let y2 = (0) in (y2)) ((begin match x3 with | [] -> []; | (z3::z4) -> z4 end)) )) else ((snd) ((((=)) (false) (true) ,(if (true) then (lam2) else (safeTail)))) ))
and lam3 = ((fun  x1 -> x1)) ((fun x2 -> (if (true) then (((&&)) (x2) (false) ) else (((=)) (true) (x2) )))) 

let welltypedProgram = (begin match let y11 = ((begin match (fst) (([],((~-)) (1) ))  with | [] -> (compose) ((if ((begin match (safeHead) ([])  with | None -> ((||)) (true) (false) ; | Some x -> x end)) then ((begin match ((@)) ([]) ([])  with | [] -> (compose) ((@)) (Fun.id) ([]) ; | (z39::z40) -> safeTail end)) else ((fst) ((safeTail,compose)) ))) (((fun  x28 -> snd)) ((fst) ((0,List.cons)) ) ) (((List.cons) ((safeTail) ([]) ) ([]) ,(snd) ((lam1,[])) )) ; | (z27::z28) -> (List.cons) ((begin match (lam2) ((if (false) then (z28) else ([])))  with | [] -> (fst) ((safeHead,true)) ; | (z47::z48) -> (Fun.id) ((Fun.id) (safeHead) )  end)) ((List.filter) ((Fun.id) ((fun (x51 : ((int) list -> (int) option)) -> true)) ) ((snd) ((false,[])) ) )  end)) in ((Fun.id) ((compose) ((begin match (Fun.id) ((safeHead) (y11) )  with | None -> safeHead; | Some x -> x end)) ((begin match (safeHead) ((List.map) (Fun.id) ([]) )  with | None -> safeTail; | Some x -> x end)) ((List.map) (let y12 = ((lam2) ([]) ) in (Fun.id)) ((fst) (([],(&&))) ) ) ) ) with | None -> ((~-)) ((if (((&&)) (((||)) ((fst) ((true,Fun.id)) ) (((<)) ((List.length) ([]) ) (let y6 = (lam3) in (0)) ) ) ((lam3) (((=)) (false) ((Fun.id) (false) ) ) ) ) then ((fst) ((((-)) (((-)) (1) (0) ) (((~-)) (0) ) ,(lam3) (((=)) (true) (true) ) )) ) else ((snd) (((fst) (((||),List.filter)) ,((+)) (((~-)) (0) ) ((lam1) (true) ) )) ))) ; | Some x -> x end)

let illtypedProgram  = (begin match let y11 = ((begin match (fst) (([],((~-)) (1) ))  with | [] -> (compose) ((if ((begin match (safeHead) ([])  with | None -> ((||)) (true) (false) ; | Some x -> x end)) then ((begin match ((@)) ([]) ([])  with | [] -> (compose) ((@)) (Fun.id) ([]) ; | (z39::z40) -> safeTail end)) else ((fst) ((safeTail,compose)) ))) (((fun  x28 -> snd)) ((fst) ((0,List.cons)) ) ) (((List.cons) ((safeTail) ([]) ) ([]) ,(snd) ((lam1,[])) )) ; | (z27::z28) -> (List.cons) ((begin match (lam2) ((if (false) then (z28) else ([])))  with | [] -> (fst) ((safeHead,true)) ; | (z47::z48) -> (Fun.id) ((Fun.id) (safeHead) )  end)) ((List.filter) ((Fun.id) ((fun (x51 : ((int) list -> (int) option)) -> true)) ) ((snd) ((false,[])) ) )  end)) in ((Fun.id) ((compose) ((begin match (Fun.id) ((safeHead) (y11) )  with | None -> (let y37 = ((List.length) ((compose) ((fun x83 -> (List.filter) ((begin match [] with | [] -> fst; | (z75::z76) -> z75 end)) (((@)) ([]) (x83) ) )) ((Fun.id) ((if ((if (false) then (false) else (true))) then ((compose) (List.filter) (Fun.id) (fst) ) else ((fun x91 -> [])))) ) ((List.filter) ((compose) ((fun x92 -> snd)) ((fun x93 -> snd)) (((&&)) (true) (true) ) ) ([]) ) ) ) in ((Fun.id) ([]) )) (let y29 = ((snd) (((List.map) ((if (((&&)) (false) (false) ) then (safeHead) else ((if (true) then (safeHead) else (safeHead))))) ((Fun.id) ((List.cons) ([]) ([]) ) ) ,((||)) (((<)) (((~-)) (0) ) (0) ) ((snd) ((safeHead,true)) ) )) ) in ((snd) (((lam2) ((fst) (([],(||))) ) ,(List.filter) ((compose) ((if (y29) then ((||)) else ((||)))) ((fun x54 -> true)) ((~-)) ) ((Fun.id) ([]) ) )) )); | Some x -> x end)) ((begin match (safeHead) ((List.map) (Fun.id) ([]) )  with | None -> safeTail; | Some x -> x end)) ((List.map) (let y12 = ((lam2) ([]) ) in (Fun.id)) ((fst) (([],(&&))) ) ) ) ) with | None -> ((~-)) ((if (((&&)) (((||)) ((fst) ((true,Fun.id)) ) (((<)) ((List.length) ([]) ) (let y6 = (lam3) in (0)) ) ) ((lam3) (((=)) (false) ((Fun.id) (false) ) ) ) ) then ((fst) ((((-)) (((-)) (1) (0) ) (((~-)) (0) ) ,(lam3) (((=)) (true) (true) ) )) ) else ((snd) (((fst) (((||),List.filter)) ,((+)) (((~-)) (0) ) ((lam1) (true) ) )) ))) ; | Some x -> x end)